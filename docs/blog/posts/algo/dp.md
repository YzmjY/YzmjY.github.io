---
date: 2024-11-22
draft: true
---

# 动态规划
动态规划问题的一般特征是存在重复子问题以及最优子结构。

<!-- more -->
对于重复子问题而言，最经典的问题便是斐波那契数列：

!!! question

    问题：斐波那契数列满足：f(n) = f(n-1)+f(n-2),给定n求f(n)？

题目已经给出了递归公式，那么很容易写出如下递归解法：
```cpp
int fibonacci(n){
    if(n == 0){
        return 0;
    }
    if(n == 1||n == 2){
        return 1;
    }
    return fibonacci(n-1)+fibonacci(n-2);
}
```

如此固然正确，但注意到有过多的重复计算，而每一重复计算都会展开为一颗递归树，因此其复杂度是不可接受的。
下面给出自底向上的解法：
```cpp
int fibonacci(n){
    if(n == 1||n == 2){
        return 1;
    }
    int i = 1;
    int j = 1;
    for(int i = 3; i<=n;i++){
        int t = i+j;
        i = j;
        j = t;
    }
    return j;
}
```
如上可以得知，当我们计算f[i]的时候，其所需要的f[i-1]和f[i-2]均已知，故不会造成子问题被重复计算。

## 解题思路
上面的斐波那契数列问题严格来说不算动态规划问题，其不存在最优子结构，只是可以很好的展示重复子问题
的重复计算对于算法的复杂度有很大的影响。对于一般的动态规划问题，其解题或者说思考方法可以从如下几
个方面入手：

- 影响结果的因素有哪些
- 如何定义dp数组
- 如何确定状态转移方程，即如何从已知推出位置
- 如何确定平凡情况的取值


## 动态规划常见问题
### 子序列问题
子序列问题大多是在一个或两个字符串中找到一个问题的最值，一般情况下dp数组的大小会设置为字符串长
度+1，来囊括空串的情况，简化边界条件的处理。
#### 只涉一个字符串
##### 最长上升子序列
!!! question

    给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

解题思路：

- 确定dp数组的含义：dp[i]为以num[i]结尾的最长子序列长度
- 确定状态转移方程：转移方程的关键在于找出num[i]与[0,i-1]结尾的最长子序列构成的更长的递增子序
  列的最大值
    ```cpp
    for(int j = 0;j<i;j++){
        if(nums[i]>nums[j]){
            dp[i] = max(dp[i],dp[j]+1);
            maxV = max(dp[i],maxV);
        }
    }
    ```
- 确定平凡情况：dp[0] = 1; 显然，子序列最少也有一个即它本身。

完整代码：

```cpp
int lengthOfLIS(vector<int>& nums) {
    vector<int> dp(nums.size(),1);
    int maxV = 1;
    for(int i = 0; i<dp.size();i++){
        for(int j = 0;j<i;j++){
            if(nums[i]>nums[j]){
                dp[i] = max(dp[i],dp[j]+1);
                maxV = max(dp[i],maxV);
            }
        }
    }
    return maxV;
}
```