---
date: 2025-06-28
categories:
  - Hot150
draft: false
---

# 189.轮转数组

## 题目

给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

示例 1:

> 输入: nums = [1,2,3,4,5,6,7], k = 3
> 输出: [5,6,7,1,2,3,4]
> 解释:
> 向右轮转 1 步: [7,1,2,3,4,5,6]
> 向右轮转 2 步: [6,7,1,2,3,4,5]
> 向右轮转 3 步: [5,6,7,1,2,3,4]

示例 2:

> 输入：nums = [-1,-100,3,99], k = 2
> 输出：[3,99,-1,-100]
> 解释: 
> 向右轮转 1 步: [99,-1,-100,3]
> 向右轮转 2 步: [3,99,-1,-100]

<!-- more -->

## 题解

### 方法一：使用额外的数组

我们可以使用额外的数组来将每个元素放到正确的位置。用 `n` 表示数组的长度，我们遍历原数组，将原数组下标为 `i` 的元素放到新数组下标为 `(i+k)\%n` 的位置，最后将新数组拷贝到原数组即可。

### 方法二：数组翻转

该方法基于如下的事实：当我们将数组的元素向右移动 `k` 次后，尾部 `k mod n` 个元素会移动至数组头部，其余元素向后移动 `k mod n` 个位置。

实现流程为：

1. 先将所有元素翻转，这样尾部的 `k mod n` 个元素就被移至数组头部。
2. 再将前 `k mod n` 个元素翻转，后 `n-k mod n` 个元素翻转，即完成了向右轮转 `k` 个位置的要求。

## 代码
### 方法一：使用额外的数组

```go
func rotate(nums []int, k int) {
    n := len(nums)
    k %= n
    newNums := make([]int,n)
    for i,num := range nums {
        newNums[(i+k)%n] = num
    }
    copy(nums,newNums)
}
```

### 方法二：数组翻转


```go
func rotate(nums []int, k int) {
    n := len(nums)
    k %= n
    reverse(nums)
    reverse(nums[:k])
    reverse(nums[k:])
}

func reverse(a []int) {
    for i, n := 0, len(a); i < n/2; i++ {
        a[i], a[n-1-i] = a[n-1-i], a[i]
    }
}
```
